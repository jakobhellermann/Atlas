import { SpinBox, Button, CheckBox, Slider, LineEdit, ListView,
    HorizontalBox, VerticalBox, GridBox, StandardButton, Palette, StandardTableView, ComboBox, TabWidget, ProgressIndicator, ScrollView } from "std-widgets.slint";

import { CCTRecording, RecordingsTable } from "recordings_table.slint";
import { TasRecording, TasRecordingState } from "tas_recording.slint";

enum ActiveWindow {
    Main,
    Record,
}

struct RenderSettings {
    width: float,
    only-render-visited: bool,
    color-mode: string,
    anti-alias: bool,
}

export component MainWindow inherits Window {
    private property <ActiveWindow> nav: Main;

    default-font-size: 11pt;
    title: "tbd";

    // main
    in property <[CCTRecording]> recordings-model: [];
    in-out property <string> error: "";

    // actions
    callback delete-recent-recordings;
    callback refresh-recordings;
    callback pick-tas-files();
    callback pick-tas-files-done([string]);

    // entrypoints
    callback record-update(float, string, bool);
    callback record-done(bool);
    callback record-ok;

    // recording
    callback record-tases([string], float, bool);
    callback abort-tas;
    private property <TasRecordingState> record-state;
    private property <[string]> record-paths;
    in-out property <float> record-progress;
    in-out property <string> record-status-text;

    // render
    in property <bool> rendering: false;
    callback render(RenderSettings);
    private property <RenderSettings> render-settings: { width: 2, only-render-visited: false, color-mode: "Gradient", anti-alias: false };

    record-done(success) => {
        record-state = success ? TasRecordingState.DoneSuccess : TasRecordingState.DoneError;
    }
    pick-tas-files-done(paths) => {
        record-paths = paths;
        if record-paths.length > 0 {
            nav = ActiveWindow.Record;
        }
    }

    preferred-width: 1080px;
    preferred-height: 720px;

    if nav == ActiveWindow.Record: r := TasRecording {
        state: record-state;
        paths: record-paths;
        progress: record-progress;
        status-text: record-status-text;

        record-tases(paths, fastforward-speed, run-as-merged) => {
            record-state = TasRecordingState.Running;
            record-status-text = "";
            record-progress = 0.0;
            record-tases(paths, fastforward-speed, run-as-merged);
        }

        ok => {
            nav = ActiveWindow.Main;
            record-state = TasRecordingState.Prepare;
            record-status-text = "";
            record-progress = 0.0;
        }
        abort => {
            nav = ActiveWindow.Main;
            abort-tas();
            record-state = TasRecordingState.Prepare;
            record-status-text = "";
            record-progress = 0.0;
        }
    }
    if nav == ActiveWindow.Main: VerticalBox {
        HorizontalBox {
            Button {
                clicked => {
                    error = "";
                    pick-tas-files();
                }

                text: "Record TASes";
            }

            Button {
                clicked => {
                    error = "";
                    delete-recent-recordings();
                }

                text: "Delete recent recodings";
            }
        }

        HorizontalLayout {
            Text {
                text: "Recent CCT Recordings";
                font-size: 18pt;
                horizontal-stretch: 1;
            }

            Button {
                horizontal-stretch: 0;
                colorize-icon: true;
                icon: @image-url("refresh.svg");

                clicked => {
                    error = "";
                    refresh-recordings();
                }
            }
        }

        RecordingsTable {
            columns: ["#", "Chapter Name", "Time", "Include"];
            values: recordings-model;
        }

        HorizontalLayout {
            VerticalLayout {
                Text {
                    font-size: 18pt;
                    text: "Render Settings";
                }

                HorizontalBox {
                    padding-left: 0;
                    padding-bottom: 0;

                    Text {
                        vertical-alignment: center;
                        text: "Line Width";
                    }

                    slider := Slider {
                        value: render-settings.width;
                        minimum: 1.0;
                        maximum: 20.0;

                        changed(val) => {
                            render-settings.width = val;
                        }
                    }

                    Text {
                        text: Math.round(slider.value * 100) / 100;
                    }
                }

                HorizontalBox {
                    padding-left: 0;
                    padding-bottom: 0;
                    alignment: start;

                    Text {
                        vertical-alignment: center;
                        text: "Color";
                    }

                    ComboBox {
                        current-value: render-settings.color-mode;
                        // Keep in sync with render()
                        model: ["Gradient", "StState", "Red"];
                        selected(val) => {
                            render-settings.color-mode = val;
                        }
                    }
                }

                HorizontalBox {
                    padding-left: 0;
                    padding-bottom: 0;
                    alignment: start;

                    Text {
                        vertical-alignment: center;
                        text: "Only include visited rooms";
                    }

                    CheckBox {
                        checked: render-settings.only-render-visited;
                        toggled => {
                            render-settings.only-render-visited = self.checked;
                        }
                    }
                }
            }
        }

        HorizontalBox {
            padding: 0px;
            alignment: space-between;

            Text {
                vertical-alignment: center;
                horizontal-stretch: 1;
                wrap: word-wrap;
                text: root.error;
                color: #ff3333;
            }

            /*pw := PopupWindow {
                x: root.width - 400px - render-button.width;
                y: -210px;
                width: 400px;
                height: 200px;

                layout := Rectangle {
                    background: Palette.background;
                    border-color: Palette.border;
                    border-width: 1px;

                    ScrollView {

                        pw-text := Text {
                            vertical-alignment: top;
                            horizontal-alignment: left;

                            text: error;
                        }
                    }
                }
            }*/

            VerticalLayout {
                alignment: end;

                render-button := Button {
                    enabled: !rendering && recordings-model.length > 0;
                    clicked => {
                        error = "";
                        root.render(render-settings);
                        // pw.show();
                    }

                    text: "Render";
                }
            }
        }
    }
}
