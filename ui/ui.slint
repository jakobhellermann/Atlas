import { SpinBox, Button, CheckBox, Slider, LineEdit, ListView,
    HorizontalBox, VerticalBox, GridBox, StandardButton, Palette, StandardTableView, ComboBox, TabWidget, ProgressIndicator, ScrollView } from "std-widgets.slint";

import { TasRecording, TasRecordingState } from "tas_recording.slint";

enum ActiveWindow {
    Main,
    Record,
}

struct RenderSettings {
    width: float,
    only-render-visited: bool,
    color-mode: string,
    anti-alias: bool,
}



struct Recording {
    i: int,
    start-time: string,
    frame-count: int,
    start-room: string,
    checked: bool,
}
struct MapRecordings {
    map-bin: string,
    chapter-name: string,
    checked: bool,
    recordings: [Recording],
}

export global Recordings {
    callback toggle-expand-map(string);
    callback toggle-expand-map-recording(string, int);
}

component ExpandButton inherits VerticalLayout {
    in-out property <bool> expanded;
    in property <bool> enabled: true;

    public function toggle() {
        expanded = !expanded;
    }//
    
    alignment: center;

    ta := TouchArea {
        enabled: enabled;
        width: 24px;
        height: 24px;

        clicked => {
            expanded = !expanded
        }

        img := Image {
            vertical-alignment: center;
            width: 24px;
            height: 24px;
            source: @image-url("assets/dropdown.svg");
            colorize: enabled ? Palette.control-foreground : Palette.control-foreground.darker(1.0);

            animate rotation-angle {
                duration: 200ms;
                easing: ease-out;
            }
        }
    }

    states [
        default when !expanded: {
            img.rotation-angle: 0;
        }
        expanded when expanded: {
            img.rotation-angle: -180deg;
        }
    ]
}

component RecordingsList {
    in property <[MapRecordings]> recordings;

    ListView {
        for map in recordings: VerticalLayout {
            HorizontalLayout {
                expand := ExpandButton {
                    expanded: false;
                }

                header-cb := CheckBox {
                    checked: map.checked;

                    toggled => {
                        map.checked = self.checked;
                        Recordings.toggle-expand-map(map.map-bin);
                    }
                }

                TouchArea {
                    width: t.preferred-width;

                    t := Text {
                        vertical-alignment: center;
                        text: map.chapter-name + (map.recordings.length > 1 ? " (" + map.recordings.length + ")" : "");
                    }

                    clicked => {
                        header-cb.checked = !header-cb.checked;
                        header-cb.toggled()
                    }
                }
            }

            Rectangle {
                clip: true;
                visible: expand.expanded || true;
                height: expand.expanded ? self.preferred-height : 0px;

                animate height { duration: 100ms; }

                VerticalLayout {
                    padding-left: 24px;

                    for recording in map.recordings: HorizontalLayout {
                        alignment: start;

                        recording-cb := CheckBox {
                            checked: recording.checked;

                            toggled => {
                                recording.checked = self.checked;
                                Recordings.toggle-expand-map-recording(map.map-bin, recording.i);
                                header-cb.checked = map.checked;
                            }
                        }

                        TouchArea {
                            HorizontalLayout {
                                spacing: 8px;
                                Text {
                                    vertical-alignment: center;
                                    text: recording.i;
                                }

                                Text {
                                    vertical-alignment: center;
                                    text: recording.start-room;
                                }

                                Text {
                                    vertical-alignment: center;
                                    text: recording.start-time;
                                }

                                Text {
                                    vertical-alignment: center;
                                    text: recording.frame-count + "f";
                                }
                            }

                            clicked => {
                                recording-cb.checked = !recording-cb.checked;
                                recording-cb.toggled();
                            }
                        }
                    }
                }
            }
        }
    }
}

export component MainWindow inherits Window {
    private property <ActiveWindow> nav: Main;

    default-font-size: 11pt;
    title: "tbd";

    in property <[MapRecordings]> recordings: [
        {
            chapter-name: "Superluminary",
            checked: true,
            recordings: [
                {
                    i: 0,
                    start-time: "13:31",
                    frame-count: 3522,
                    checked: true,
                },
                {
                    i: 1,
                    start-time: "13:34",
                    frame-count: 27,
                    checked: false,
                },
            ]
        },
        { chapter-name: "The Solar Express" },
        { chapter-name: "Pinball Purgatory" },
        { chapter-name: "Cave of the Crimson Sky" },
    ];

    // main
    in-out property <string> error: "";

    // actions
    callback delete-recent-recordings;
    callback refresh-recordings;
    callback pick-tas-files();
    callback pick-tas-files-done([string]);

    // entrypoints
    callback record-update(float, string, bool);
    callback record-done(bool);
    callback record-ok;

    // recording
    callback record-tases([string], float, bool);
    callback abort-tas;
    private property <TasRecordingState> record-state;
    private property <[string]> record-paths;
    in-out property <float> record-progress;
    in-out property <string> record-status-text;

    // render
    in property <bool> rendering: false;
    callback render(RenderSettings);
    private property <RenderSettings> render-settings: { width: 2, only-render-visited: false, color-mode: "Gradient", anti-alias: false };

    record-done(success) => {
        record-state = success ? TasRecordingState.DoneSuccess : TasRecordingState.DoneError;
    }
    pick-tas-files-done(paths) => {
        record-paths = paths;
        if record-paths.length > 0 {
            nav = ActiveWindow.Record;
        }
    }

    preferred-width: 1080px;
    preferred-height: 720px;

    if nav == ActiveWindow.Record: r := TasRecording {
        state: record-state;
        paths: record-paths;
        progress: record-progress;
        status-text: record-status-text;

        record-tases(paths, fastforward-speed, run-as-merged) => {
            record-state = TasRecordingState.Running;
            record-status-text = "";
            record-progress = 0.0;
            record-tases(paths, fastforward-speed, run-as-merged);
        }

        ok => {
            nav = ActiveWindow.Main;
            record-state = TasRecordingState.Prepare;
            record-status-text = "";
            record-progress = 0.0;
        }
        abort => {
            nav = ActiveWindow.Main;
            abort-tas();
            record-state = TasRecordingState.Prepare;
            record-status-text = "";
            record-progress = 0.0;
        }
    }
    if nav == ActiveWindow.Main: VerticalBox {
        HorizontalBox {
            Button {
                clicked => {
                    error = "";
                    record-state = TasRecordingState.Prepare;
                    pick-tas-files();
                }

                text: "Record TASes";
            }

            Button {
                clicked => {
                    error = "";
                    delete-recent-recordings();
                }

                text: "Delete recent recodings";
            }
        }

        HorizontalLayout {
            Text {
                text: "Recent CCT Recordings";
                font-size: 18pt;
                horizontal-stretch: 1;
            }

            Button {
                horizontal-stretch: 0;
                colorize-icon: true;
                icon: @image-url("refresh.svg");

                clicked => {
                    error = "";
                    refresh-recordings();
                }
            }
        }

        RecordingsList {
            recordings: recordings;
        }

        HorizontalLayout {
            VerticalLayout {
                Text {
                    font-size: 18pt;
                    text: "Render Settings";
                }

                HorizontalBox {
                    padding-left: 0;
                    padding-bottom: 0;

                    Text {
                        vertical-alignment: center;
                        text: "Line Width";
                    }

                    slider := Slider {
                        value: render-settings.width;
                        minimum: 1.0;
                        maximum: 20.0;

                        changed(val) => {
                            render-settings.width = val;
                        }
                    }

                    Text {
                        text: Math.round(slider.value * 100) / 100;
                    }
                }

                HorizontalBox {
                    padding-left: 0;
                    padding-bottom: 0;
                    alignment: start;

                    Text {
                        vertical-alignment: center;
                        text: "Color";
                    }

                    ComboBox {
                        current-value: render-settings.color-mode;
                        // Keep in sync with render()
                        model: ["Gradient", "StState", "Red"];
                        selected(val) => {
                            render-settings.color-mode = val;
                        }
                    }
                }

                HorizontalBox {
                    padding-left: 0;
                    padding-bottom: 0;
                    alignment: start;

                    Text {
                        vertical-alignment: center;
                        text: "Only include visited rooms";
                    }

                    CheckBox {
                        checked: render-settings.only-render-visited;
                        toggled => {
                            render-settings.only-render-visited = self.checked;
                        }
                    }
                }
            }
        }

        HorizontalBox {
            padding: 0px;
            alignment: space-between;

            Text {
                vertical-alignment: center;
                horizontal-stretch: 1;
                wrap: word-wrap;
                text: root.error;
                color: #ff3333;
            }

            /*pw := PopupWindow {
                x: root.width - 400px - render-button.width;
                y: -210px;
                width: 400px;
                height: 200px;

                layout := Rectangle {
                    background: Palette.background;
                    border-color: Palette.border;
                    border-width: 1px;

                    ScrollView {

                        pw-text := Text {
                            vertical-alignment: top;
                            horizontal-alignment: left;

                            text: error;
                        }
                    }
                }
            }*/

            VerticalLayout {
                alignment: end;

                render-button := Button {
                    enabled: !rendering;
                    clicked => {
                        error = "";
                        root.render(render-settings);
                        // pw.show();
                    }

                    text: "Render";
                }
            }
        }
    }
}
